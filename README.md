# RV32I-5Stage-Pipelined-CPU
ğŸš€ RV32I-A7: My First Pipelined RISC-V CPU CoreğŸŒŸ Executive Summary: The Journey BeginsThis is my inaugural CPU design project! I am implementing a complete, synthesizable 32-bit RISC-V processor core from scratch. This project is a deep dive into the core principles of modern computer architecture, bringing a textbook classicâ€”the 5-stage pipelineâ€”to life on real hardware.The core is designed to successfully run the RV32I Base Integer Instruction Set on the Digilent Nexys A7-100T FPGA. The success of this project hinges on mastering the most challenging aspects of CPU design: pipeline hazard resolution.AspectDetailProject StatusActive DevelopmentTarget ISARISC-V RV32I (32-bit Base Integer Instruction Set)MicroarchitectureClassic 5-Stage Pipeline (IF, ID, EX, MEM, WB)Target HardwareDigilent Nexys A7-100T (Xilinx Artix-7)LanguageVerilog HDLKey ChallengeHazard Detection and Data Forwarding implementation.âš™ï¸ Architecture and PipeliningThe CPU is a single-issue, in-order processor. Instructions flow through five stages, separated by clocked Pipeline Registers to achieve an ideal CPI (Cycles Per Instruction) of 1.1. The 5-Stage Pipeline FlowStageAbbreviationCore FunctionInstruction FetchIFFetches 32-bit instruction from Instruction Memory (IMEM) using the PC.Instruction DecodeIDDecodes the instruction, reads the Register File (x0-x31), and computes immediate values.ExecuteEXPerforms ALU operations, computes load/store addresses, and handles Forwarding logic.Memory AccessMEMExecutes Data Memory reads ($\text{LW}$) or writes ($\text{SW}$).Write BackWBWrites the final result back to the Register File.2. Hazard Management: The Heart of the DesignThis core includes sophisticated logic to prevent functional errors caused by overlapping instructions:Hazard TypeSolution ImplementedDetailData Hazard (RAW)Data Forwarding (Bypassing)Data is bypassed from the $\text{EX/MEM}$ or $\text{MEM/WB}$ register directly to the $\text{EX}$ stage input, avoiding most stalls.Load-Use HazardPipeline Stall (Bubble)The Hazard Detection Unit inserts one $\text{NOP}$ into the pipeline if a $\text{LW}$ instruction's result is needed in the very next cycle.Control HazardPipeline FlushConditional branches ($\text{BEQ, BLT}$) are resolved in the $\text{EX}$ stage, and the incorrectly fetched instructions are flushed/nullified immediately.ğŸ“ Repository StructureThe project is organized to separate the core logic from the board-specific constraints and simulation files..
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ cpu_core.v                # Top-level pipeline instantiation
â”‚   â”œâ”€â”€ modules/                  # ALU, Register File, Data/Instruction Memory
â”‚   â””â”€â”€ pipeline_logic/           # Forwarding Unit, Hazard Detection, Pipeline Registers
â”œâ”€â”€ asm_tests/
â”‚   â”œâ”€â”€ sample_fibonacci.s        # RISC-V source code
â”‚   â””â”€â”€ mem_init.hex              # Machine code to load into IMEM
â”œâ”€â”€ constraints/
â”‚   â””â”€â”€ nexys_a7_rv32i.xdc        # Pin assignments, clock constraints for the FPGA
â””â”€â”€ testbench/
    â””â”€â”€ cpu_tb.v                  # Simulation testbench for functional verification
ğŸ› ï¸ Build and VerificationPrerequisitesAMD Vivado Design Suite (Recommended version: 2020.2 or newer)RISC-V GNU Toolchain (For compiling custom assembly/C code)Nexys A7-100T Board FilesStep-by-Step ImplementationProject Setup: Create a new Vivado RTL project, targeting the Nexys A7-100T. Add all .v files from the src/ directory and link the .xdc file.Simulation: Run the cpu_tb.v testbench to confirm correct behavioral execution, focusing especially on the hazard scenarios.Synthesis and Implementation: Run the full flow in Vivado, ensuring the design passes the Static Timing Analysis dictated by the clock constraint in the $\text{.xdc}$ file.FPGA Deployment: Program the generated bitstream onto the Nexys A7-100T. Observe output on the on-board switches (input) and LEDs (output/status register monitoring).Next StepsIntegrate the $\text{M}$ Extension (Multiplication/Division).Add a simple I/O interface via the USB-UART bridge.
